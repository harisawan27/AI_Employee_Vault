"""
WEBXES Tech — Cloud Agent

Runs on cloud VM. Polls Needs_Action/ for emails, claims them via move to
In_Progress/cloud/, creates template draft replies in Updates/, and signals
for local sync.

No AI reasoning — just template-based drafts. Local Claude Code refines them.

Usage:
    python cloud_agent.py          # Run polling loop
    python cloud_agent.py --once   # Process once and exit
"""

import argparse
import logging
import time
from datetime import datetime
from pathlib import Path

from config import (
    VAULT_PATH, NEEDS_ACTION, IN_PROGRESS_CLOUD, UPDATES, SIGNALS,
    DONE, IS_CLOUD, WORK_ZONE, ensure_dirs,
)
from audit_logger import audit_log

# Logging
LOGS = VAULT_PATH / "Logs"
LOGS.mkdir(exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(LOGS / "cloud_agent.log", encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
log = logging.getLogger("cloud_agent")

POLL_INTERVAL = 60  # seconds


def parse_frontmatter(filepath: Path) -> dict:
    """Extract YAML frontmatter from a markdown file."""
    text = filepath.read_text(encoding="utf-8")
    if not text.startswith("---"):
        return {}
    parts = text.split("---", 2)
    if len(parts) < 3:
        return {}
    meta = {}
    for line in parts[1].strip().split("\n"):
        if ":" in line:
            key, _, val = line.partition(":")
            meta[key.strip()] = val.strip()
    return meta


def claim_file(filepath: Path) -> Path:
    """Move a file to In_Progress/cloud/ to claim it (prevents double-work)."""
    dest = IN_PROGRESS_CLOUD / filepath.name
    filepath.rename(dest)
    log.info(f"Claimed: {filepath.name} -> In_Progress/cloud/")
    return dest


def create_draft(meta: dict, original_content: str, source_filename: str) -> Path:
    """Create a template draft reply in Updates/."""
    now = datetime.now()
    sender = meta.get("from", "Unknown Sender")
    subject = meta.get("subject", "No Subject")

    # Extract email snippet from content
    snippet = ""
    parts = original_content.split("---", 2)
    if len(parts) >= 3:
        content_section = parts[2]
        if "## Email Content" in content_section:
            snippet = content_section.split("## Email Content", 1)[1]
            if "## Suggested Actions" in snippet:
                snippet = snippet.split("## Suggested Actions")[0]
            snippet = snippet.strip()

    draft_filename = f"EMAIL_DRAFT_{now.strftime('%Y%m%d_%H%M%S')}_{source_filename}"
    draft_path = UPDATES / draft_filename

    draft_content = f"""---
type: email_draft
original_file: {source_filename}
from: {sender}
subject: Re: {subject}
generated: {now.isoformat()}
generated_by: cloud_agent
status: needs_refinement
---

# Draft Reply

**To:** {sender}
**Subject:** Re: {subject}
**Generated:** {now.strftime('%Y-%m-%d %H:%M:%S')} (cloud template)

---

Dear {sender.split('<')[0].strip()},

Thank you for your email regarding "{subject}".

[CLAUDE: Please refine this draft with appropriate context and tone per Company Handbook]

Original message snippet:
> {snippet[:500] if snippet else '(no content extracted)'}

Best regards,
WEBXES Tech

---

## Cloud Agent Notes
- This is a template draft generated by the cloud agent
- Requires local Claude Code refinement before sending
- Original file: {source_filename}
"""

    draft_path.write_text(draft_content, encoding="utf-8")
    log.info(f"Draft created: {draft_filename}")
    return draft_path


def create_signal(signal_type: str, details: dict):
    """Create a signal file for local sync to pick up."""
    now = datetime.now()
    filename = f"{signal_type}_{now.strftime('%Y%m%d_%H%M%S')}.json"
    signal_path = SIGNALS / filename

    import json
    signal_data = {
        "type": signal_type,
        "timestamp": now.isoformat(),
        "zone": WORK_ZONE,
        "details": details,
    }
    signal_path.write_text(json.dumps(signal_data, indent=2), encoding="utf-8")
    log.info(f"Signal created: {filename}")


def process_emails():
    """Scan Needs_Action/ for email files and process them."""
    if not NEEDS_ACTION.exists():
        return

    email_files = list(NEEDS_ACTION.glob("EMAIL_*.md"))
    if not email_files:
        return

    log.info(f"Found {len(email_files)} email(s) to process")

    for filepath in email_files:
        try:
            meta = parse_frontmatter(filepath)
            content = filepath.read_text(encoding="utf-8")

            # Claim the file
            claimed = claim_file(filepath)

            # Create template draft
            draft_path = create_draft(meta, content, filepath.name)

            # Signal local
            create_signal("new_draft", {
                "draft_file": draft_path.name,
                "original_file": filepath.name,
                "sender": meta.get("from", "unknown"),
                "subject": meta.get("subject", "unknown"),
            })

            # Move original to Done/
            done_path = DONE / claimed.name
            DONE.mkdir(exist_ok=True)
            claimed.rename(done_path)
            log.info(f"Original moved to Done/: {claimed.name}")

            audit_log("cloud_agent", "email_drafted", {
                "original": filepath.name,
                "draft": draft_path.name,
                "sender": meta.get("from", ""),
            })

        except Exception as e:
            log.error(f"Error processing {filepath.name}: {e}")
            audit_log("cloud_agent", "process_error",
                      {"file": filepath.name}, status="error", error=str(e))


def run_loop():
    """Main polling loop."""
    log.info("=== WEBXES Tech Cloud Agent Starting ===")
    log.info(f"Zone: {WORK_ZONE}")
    log.info(f"Vault: {VAULT_PATH}")
    log.info(f"Polling every {POLL_INTERVAL}s")

    ensure_dirs()

    try:
        while True:
            process_emails()
            time.sleep(POLL_INTERVAL)
    except KeyboardInterrupt:
        log.info("Cloud Agent stopped by user.")


def main():
    parser = argparse.ArgumentParser(description="WEBXES Tech Cloud Agent")
    parser.add_argument("--once", action="store_true", help="Process once and exit")
    args = parser.parse_args()

    ensure_dirs()

    if args.once:
        process_emails()
    else:
        run_loop()


if __name__ == "__main__":
    main()
